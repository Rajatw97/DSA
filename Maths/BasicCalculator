Q> Given a string s which represents an expression, evaluate this expression and return its value. The integer division should truncate toward zero.
You may assume that the given expression is always valid. All intermediate results will be in the range of [-231, 231 - 1].
Input: s = " 3+5 / 2 "
Output: 5

TC: O(n)
class Solution {
    public int calculate(String s) {
        if(s == null || s.length() == 0) return 0;
        int curr = 0;
        int sum  = 0;
        int last = 0;
        char op = '+';
        char[] ch = s.toCharArray();
        for(int i  = 0; i < ch.length; i++){
            if(Character.isDigit(ch[i]))
                curr = curr * 10 + ch[i] - '0';
            if(!Character.isDigit(ch[i]) && ch[i] != ' ' || i == ch.length - 1){
                if(op == '+'){
                    sum += last;
                    last = curr;
                } else if(op == '-'){
                    sum += last;
                    last = -curr;
                } else if(op == '*')
                    last = last * curr;
                else if(op == '/')
                    last = last / curr;
                op = ch[i];
                curr = 0;
            }
        }
        sum += last;
        return sum;
    }
}

Variation: Given a string s representing a valid expression, implement a basic calculator to evaluate it, and return the result of the evaluation.
Input: s = "(1+(4+5+2)-3)+(6+8)"
Output: 23
TC: O(n), where n is the length of the string
SC: O(number of brackets)

class Solution {
    int idx; // this index traverse the string in one pass, between different level of recursion
    public int calculate(String s) {
        idx = 0; // Initialization should be here
        return calc(s);
    }
    
    private int calc(String s) {
        int res = 0, num = 0, sign = 1;
        while (idx < s.length()) {
            char c = s.charAt(idx++);
            if (c >= '0' && c <= '9') num = num * 10 + c - '0';
            else if (c == '(') num = calc(s); // ( is start of a new sub-problem, Let recursion solve the sub-problem
            else if (c == ')') return res + sign * num;
            else if (c == '+' || c == '-') { // only when we meet a new sign, we know a while number has been read
                res += sign * num;
                num = 0;
                sign = c == '-' ? -1 : 1;
            }
        }
        return res + sign * num; // last number is not processed yet
    }
}
